<html>
<head>
    <title>Puzzle Bobble</title>
</head>
<body>
</body>
<script type="text/javascript" src="js/RequestAnimationFrame.js"></script>
<script type="text/javascript" src="js/Tween.js"></script>
<script type="text/javascript">

    ///GameStateManagement.js
    var GAMESTATEMANAGEMENT = GAMESTATEMANAGEMENT || {};
    var PUZZLEBOBBLEGAME = PUZZLEBOBBLEGAME || {};

    GAMESTATEMANAGEMENT.CANVAS_WIDTH = 600;
    GAMESTATEMANAGEMENT.CANVAS_HEIGHT = 600;
    PUZZLEBOBBLEGAME.FIELD_STARTX = 50;
    PUZZLEBOBBLEGAME.FIELD_STARTY = 60;
    PUZZLEBOBBLEGAME.FIELD_ENDX = 600 - 50;
    PUZZLEBOBBLEGAME.FIELD_ENDY = 600 - 30;
    PUZZLEBOBBLEGAME.SCORE_POSITIONX = 40;
    PUZZLEBOBBLEGAME.SCORE_POSITIONY = 35;
    PUZZLEBOBBLEGAME.SCORE_FONT = "30pt Calibri";
    PUZZLEBOBBLEGAME.BUBBLE_RADIO = 25;
    PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE = PUZZLEBOBBLEGAME.BUBBLE_RADIO * Math.sqrt(3);
    PUZZLEBOBBLEGAME.BUBBLE_SPEED = 10;

    //Common.js
    var COMMON = COMMON || {};

    //ScreenState.js
    GAMESTATEMANAGEMENT.ScreenState = {

        TransitionOn: 0,
        Active: 1,
        TransitionOff: 2,
        Hidden: 3
    };

    COMMON.Keys = {

        Up: 0,
        Down: 1,
        Left: 2,
        Right: 3,
        Enter: 4
    };

    GAMESTATEMANAGEMENT.Timer = function (screenManager) {
        var _cyclic = false;
        var _cycleStart;
        var _period;
        var _screenManager = screenManager;

        this.start = function (period, cyclic) {
            _period = period || 0;
            
            if (cyclic != undefined) 
                cyclic = _cyclic;

            _cycleStart = _screenManager.getTotalGameTime();
        };

        this.stop = function () {
            this.start(0);
        };

        this.check = function () {
            if (_period == 0)
                return false;

            if (_screenManager.getTotalGameTime() - _cycleStart >= _period) {
                if (_cyclic) {
                    _cycleStart = _screenManager.getTotalGameTime() - ((_screenManager.getTotalGameTime() - _cycleStart) % _period);
                } else {
                    period = 0;
                }
                return true;
            }

            return false;

        };
    };

    //InputState.js
    GAMESTATEMANAGEMENT.InputState = function () {

        var currentKeyStates = [false, false, false, false, false];
        var lastKeyStates = [false, false, false, false, false];

        document.addEventListener("keydown", onKeyDown, false);
        document.addEventListener("keyup", onKeyUp, false);

        function onKeyDown(ev) {

            //alert(ev.keyCode);

            if (ev.keyCode == 38)
                currentKeyStates[COMMON.Keys.Up] = true;
            if (ev.keyCode == 40)
                currentKeyStates[COMMON.Keys.Down] = true;
            if (ev.keyCode == 13)
                currentKeyStates[COMMON.Keys.Enter] = true;
            if (ev.keyCode == 37)
                currentKeyStates[COMMON.Keys.Left] = true;
            if (ev.keyCode == 39)
                currentKeyStates[COMMON.Keys.Right] = true;
        }

        function onKeyUp(ev) {

            //Para que funcione en Chrome la tecla Enter en onKeyUp
            currentKeyStates[COMMON.Keys.Enter] = false;
            lastKeyStates[COMMON.Keys.Enter] = false;

            if (ev.keyCode == 38) {
                currentKeyStates[COMMON.Keys.Up] = false;
                lastKeyStates[COMMON.Keys.Up] = false;
            }
            if (ev.keyCode == 40) {
                currentKeyStates[COMMON.Keys.Down] = false;
                lastKeyStates[COMMON.Keys.Down] = false;
            }
            if (ev.keyCode == 13) {
                currentKeyStates[COMMON.Keys.Enter] = false;
                lastKeyStates[COMMON.Keys.Enter] = false;
            }
            if (ev.keyCode == 37) {
                currentKeyStates[COMMON.Keys.Left] = false;
                lastKeyStates[COMMON.Keys.Left] = false;
            }
            if (ev.keyCode == 39) {
                currentKeyStates[COMMON.Keys.Right] = false;
                lastKeyStates[COMMON.Keys.Right] = false;
            }
            
        }


        this.isKeyDown = function (key) {
            return currentKeyStates[key];
        };

        this.isNewKeyPress = function (key) {

            if (lastKeyStates[key] == true) return false;

            if (currentKeyStates[key] == true) {
                lastKeyStates[key] = true;
                return true;
            }

        };

    };

    //ScreenManager.js
    GAMESTATEMANAGEMENT.ScreenManager = function () {

        var gameTime = { elapsedGameTime: 0, totalGameTime: 0 };
        var screens = new Array();
        var screensToUpdate = new Array();
        var lastDate = new Date().getTime();
        var input = new GAMESTATEMANAGEMENT.InputState();

        var canvas = document.createElement("canvas");
        canvas.id = "myCanvas";
        canvas.width = GAMESTATEMANAGEMENT.CANVAS_WIDTH;
        canvas.height = GAMESTATEMANAGEMENT.CANVAS_HEIGHT;
        document.body.appendChild(canvas);

        this.context = canvas.getContext("2d");

        this.getTotalGameTime = function () {
            return gameTime.totalGameTime;
        };

        this.getElapsedGameTime = function () {
            return gameTime.elapsedGameTime;
        };


        this.getScreenCount = function () {
            return screens.length;
        };

        this.getScreens = function () {
            var screensArray = new Array();
            for (var i = 0; i < screens.length; i++) {
                screensArray.push(screens[i]);
            }
            return screensArray;
        };

        this.clear = function () {

            this.context.clearRect(0, 0, GAMESTATEMANAGEMENT.CANVAS_WIDTH, GAMESTATEMANAGEMENT.CANVAS_HEIGHT);
        };

        this.setSettingValue = function (key, value) {
            localStorage.setItem(key, value);
        };

        this.getSettingValue = function (key) {
            return localStorage.getItem(key);
        };

        this.update = function (gameTime) {

            screensToUpdate.splice(0, screensToUpdate.length);
            for (var i = 0; i < screens.length; i++) {
                screensToUpdate.push(screens[i]);
            }

            var otherScreenHasFocus = false;
            var coveredByOtherScreen = false;

            while (screensToUpdate.length > 0) {
                // Pop the topmost screen off the waiting list.
                var screen = screensToUpdate.pop();

                // Update the screen.
                screen.update(gameTime, otherScreenHasFocus, coveredByOtherScreen);

                if (screen.screenState == GAMESTATEMANAGEMENT.ScreenState.TransitionOn ||
                screen.screenState == GAMESTATEMANAGEMENT.ScreenState.Active) {
                    // If this is the first active screen we came across,
                    // give it a chance to handle input.
                    if (!otherScreenHasFocus) {

                        screen.handleInput(input);
                        otherScreenHasFocus = true;
                    }

                    // If this is an active non-popup, inform any subsequent
                    // screens that they are covered by it.
                    if (!screen.isPopup)
                        coveredByOtherScreen = true;
                }
            }
        };

        this.draw = function (gameTime) {

            this.context.clearRect(0, 0, GAMESTATEMANAGEMENT.CANVAS_WIDTH, GAMESTATEMANAGEMENT.CANVAS_HEIGHT);

            for (var i = 0; i < screens.length; i++) {
                if (screens[i].screenState == GAMESTATEMANAGEMENT.ScreenState.Hidden)
                    continue;

                screens[i].draw(gameTime, this.context);
            }
        };

        this.render = function (elapsedTime) {

            //gameTime.elapsedGameTime = elapsedTime;
            //gameTime.elapsedGameTime = new Date().getTime() - lastDate;
            gameTime.elapsedGameTime = elapsedTime;
       
            gameTime.totalGameTime += gameTime.elapsedGameTime;

            //console.log("" + elapsedTime);

            // 1 / (float)gameTime.ElapsedGameTime.TotalSeconds;

            this.update(gameTime);
            this.clear();
            this.draw(gameTime);

            //lastDate = new Date().getTime();



        };

        this.addScreen = function (screen) {

            screen.screenManager = this;
            screen.isExiting = false;
            screens.push(screen);
            screen.loadContent();
        };

        this.removeScreen = function (screen) {

            for (var i = 0; i < screens.length; i++) {

                if (screens[i] == screen) {
                    screen.unloadContent();
                    screens.splice(i, 1);
                }
            }
        };

        this.fadeBackBufferToBlack = function (alpha) {

            this.context.fillStyle = "rgba(0,0,0," + alpha + ")";
            this.context.fillRect(0, 0, GAMESTATEMANAGEMENT.CANVAS_WIDTH, GAMESTATEMANAGEMENT.CANVAS_HEIGHT);
        };

    };

    //GameScreen.js
    GAMESTATEMANAGEMENT.GameScreen = function () {

        this.isPopup = false;
        this.transitionOnTime = 0;
        this.transitionOffTime = 0;
        this.screenManager = null;

        //Gets the current position of the screen transition, ranging
        //from zero (fully active, no transition) to one (transitioned
        //fully off to nothing).
        this.transitionPosition = 1;

        //Gets the current alpha of the screen transition, ranging
        //from 1 (fully active, no transition) to 0 (transitioned
        //fully off to nothing).
        this.getTransitionAlpha = function () {
            return 1 - this.transitionPosition;
        };

        this.screenState = GAMESTATEMANAGEMENT.ScreenState.TransitionOn;

        this.isExiting = false;

        var _otherScreenHasFocus;
        this.isActive = function () {
            return !_otherScreenHasFocus && (this.screenState == GAMESTATEMANAGEMENT.ScreenState.TransitionOn ||
                        this.screenState == GAMESTATEMANAGEMENT.ScreenState.Active);
        };

        this.updateTransition = function (gameTime, time, direction) {
            // How much should we move by?
            var transitionDelta;

            if (time == 0)
                transitionDelta = 1;
            else
                transitionDelta = gameTime.elapsedGameTime / time;

            // Update the transition position.
            this.transitionPosition += transitionDelta * direction;

            // Did we reach the end of the transition?
            if (((direction < 0) && (this.transitionPosition <= 0)) ||
                ((direction > 0) && (this.transitionPosition >= 1))) {
                this.transitionPosition = this.clamp(this.transitionPosition, 0, 1);
                return false;
            }

            // Otherwise we are still busy transitioning.
            return true;
        };

        this.update = function (gameTime, otherScreenHasFocus, coveredByOtherScreen) {

            _otherScreenHasFocus = otherScreenHasFocus;

            if (this.isExiting) {
                // If the screen is going away to die, it should transition off.
                this.screenState = GAMESTATEMANAGEMENT.ScreenState.TransitionOff;

                if (!this.updateTransition(gameTime, this.transitionOffTime, 1)) {
                    // When the transition finishes, remove the screen.
                    this.screenManager.removeScreen(this);
                }
            }
            else if (coveredByOtherScreen) {

                // If the screen is covered by another, it should transition off.
                if (this.updateTransition(gameTime, this.transitionOffTime, 1)) {
                    // Still busy transitioning.
                    this.screenState = GAMESTATEMANAGEMENT.ScreenState.TransitionOff;
                }
                else {
                    // Transition finished!
                    this.screenState = GAMESTATEMANAGEMENT.ScreenState.Hidden;
                }
            }
            else {
                // Otherwise the screen should transition on and become active.
                if (this.updateTransition(gameTime, this.transitionOnTime, -1)) {
                    // Still busy transitioning.
                    this.screenState = GAMESTATEMANAGEMENT.ScreenState.TransitionOn;
                }
                else {
                    // Transition finished!
                    this.screenState = GAMESTATEMANAGEMENT.ScreenState.Active;
                }
            }

        };

        this.clamp = function (value, min, max) {

            if (value < min) return min;
            if (value > max) return max;

            return value;
        };

        //virtual
        this.draw = function (gameTime, context) {
        };

        //virtual
        this.loadContent = function () {
        };

        //virtual
        this.unloadContent = function () {
        };

        //virtual
        this.handleInput = function(inputState) {
        };

        this.exitScreen = function () {

            if (this.transitionOffTime == 0) {
                // If the screen has a zero transition time, remove it immediately.
                this.screenManager.removeScreen(this);
            }
            else {
                // Otherwise flag that it should transition off and then exit.
                this.isExiting = true;
            }
        };
    };

    ///BackgroundScreen.js
    GAMESTATEMANAGEMENT.BackgroundScreen = function () {

        this.transitionOnTime = 500;
        this.transitionOffTime = 500;
        var scrollX = 0;
        var scrollY = 0;
        var backgroundImage;
        var backgroundImage2;

        var scrollFactor = 1;
        var scrollFactor2 = 0.5;

        var test = 0;

        var baseUpdate = this.update;
        this.update = function (gameTime, otherScreenHasFocus, coveredByOtherScreen) {

            scrollX++;
            baseUpdate.call(this, gameTime, otherScreenHasFocus, false);
        };


        this.loadContent()
        {
            backgroundImage = new Image();
            backgroundImage.src = "b2.png";
            backgroundImage2 = new Image();
            backgroundImage2.src = "b3.png";
        };

        this.draw = function (gameTime, context) {


            context.fillStyle = "green";
            context.fillRect(0, 0, GAMESTATEMANAGEMENT.CANVAS_WIDTH, GAMESTATEMANAGEMENT.CANVAS_HEIGHT);

            //context.drawImage(backgroundImage, 0, 0);
            var areaDrawn = [0, 0];

            for (var y = 0; y < GAMESTATEMANAGEMENT.CANVAS_HEIGHT; y += areaDrawn[1]) {
                for (var x = 0; x < GAMESTATEMANAGEMENT.CANVAS_WIDTH; x += areaDrawn[0]) {
                    // the top left corner to start drawing the next tile from
                    var newPosition = [0 + x, 0 + y];
                    // the amount of space left in which to draw
                    var newFillArea = [GAMESTATEMANAGEMENT.CANVAS_WIDTH - x, GAMESTATEMANAGEMENT.CANVAS_HEIGHT - y];
                    // the first time around you have to start drawing from the middle of the image
                    // subsequent tiles alwyas get drawn from the top or left
                    var newScrollPosition = [0, 0];
                    if (x == 0) newScrollPosition[0] = scrollX * scrollFactor;
                    if (y == 0) newScrollPosition[1] = scrollY * scrollFactor;
                    areaDrawn = this.drawRepeat(context, newPosition, newFillArea, newScrollPosition);
                }
            }



            var areaDrawn2 = [0, 0];

            for (var y = 0; y < GAMESTATEMANAGEMENT.CANVAS_HEIGHT; y += areaDrawn2[1]) {
                for (var x = 0; x < GAMESTATEMANAGEMENT.CANVAS_WIDTH; x += areaDrawn2[0]) {
                    // the top left corner to start drawing the next tile from
                    var newPosition = [0 + x, 0 + y];
                    // the amount of space left in which to draw
                    var newFillArea = [GAMESTATEMANAGEMENT.CANVAS_WIDTH - x, GAMESTATEMANAGEMENT.CANVAS_HEIGHT - y];
                    // the first time around you have to start drawing from the middle of the image
                    // subsequent tiles alwyas get drawn from the top or left
                    var newScrollPosition = [0, 0];
                    if (x == 0) newScrollPosition[0] = scrollX * scrollFactor2;
                    if (y == 0) newScrollPosition[1] = scrollY * scrollFactor2;
                    areaDrawn2 = this.drawRepeat2(context, newPosition, newFillArea, newScrollPosition);
                }
            }


        };

        this.drawRepeat = function (context, newPosition, newFillArea, newScrollPosition) {
            // find where in our repeating texture to start drawing (the top left corner)
            var xOffset = Math.abs(newScrollPosition[0]) % backgroundImage.width;
            var yOffset = Math.abs(newScrollPosition[1]) % backgroundImage.height;
            var left = newScrollPosition[0] < 0 ? backgroundImage.width - xOffset : xOffset;
            var top = newScrollPosition[1] < 0 ? backgroundImage.height - yOffset : yOffset;
            var width = newFillArea[0] < backgroundImage.width - left ? newFillArea[0] : backgroundImage.width - left;
            var height = newFillArea[1] < backgroundImage.height - top ? newFillArea[1] : backgroundImage.height - top;

            // draw the image
            context.drawImage(backgroundImage, left, top, width, height, newPosition[0], newPosition[1], width, height);

            return [width, height];
        };


        this.drawRepeat2 = function (context, newPosition, newFillArea, newScrollPosition) {
            // find where in our repeating texture to start drawing (the top left corner)
            var xOffset = Math.abs(newScrollPosition[0]) % backgroundImage2.width;
            var yOffset = Math.abs(newScrollPosition[1]) % backgroundImage2.height;
            var left = newScrollPosition[0] < 0 ? backgroundImage2.width - xOffset : xOffset;
            var top = newScrollPosition[1] < 0 ? backgroundImage2.height - yOffset : yOffset;
            var width = newFillArea[0] < backgroundImage2.width - left ? newFillArea[0] : backgroundImage2.width - left;
            var height = newFillArea[1] < backgroundImage2.height - top ? newFillArea[1] : backgroundImage2.height - top;

            // draw the image
            context.drawImage(backgroundImage2, left, top, width, height, newPosition[0], newPosition[1], width, height);

            return [width, height];
        };


    };

    GAMESTATEMANAGEMENT.BackgroundScreen.prototype = new GAMESTATEMANAGEMENT.GameScreen();
    GAMESTATEMANAGEMENT.BackgroundScreen.constructor = GAMESTATEMANAGEMENT.BackgroundScreen;

    ///GameOverScreen.js
    GAMESTATEMANAGEMENT.GameOverScreen = function (score) {

        var gameOverPhrase = new Array();
        var timer = 0;
        var _score = score;

        this.transitionOffTime = 100;
        this.transitionOnTime = 100;

        this.accepted = new COMMON.Event();
        this.canceled = new COMMON.Event();

        gameOverPhrase.push("H");
        gameOverPhrase.push("A");
        gameOverPhrase.push("S");
        gameOverPhrase.push("P");
        gameOverPhrase.push("E");
        gameOverPhrase.push("R");
        gameOverPhrase.push("D");
        gameOverPhrase.push("I");
        gameOverPhrase.push("D");
        gameOverPhrase.push("O");


        this.position0 = { x: 50, y: -10 }; //H
        this.position1 = { x: 100, y: -10 }; //A
        this.position2 = { x: 150, y: -10 }; //S
        this.position3 = { x: 250, y: -10 }; //C
        this.position4 = { x: 300, y: -10 }; //H
        this.position5 = { x: 350, y: -10 }; //O
        this.position6 = { x: 400, y: -10 }; //C
        this.position7 = { x: 450, y: -10 }; //A
        this.position8 = { x: 500, y: -10 }; //D
        this.position9 = { x: 550, y: -10 }; //O 
        this.position10 = { x: GAMESTATEMANAGEMENT.CANVAS_WIDTH / 2, y: -500 }; //O 


        new TWEEN.Tween(this.position0).to({ y: GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2 }, 1000).easing(TWEEN.Easing.Bounce.EaseOut).start();
        new TWEEN.Tween(this.position1).to({ y: GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2 }, 1200).easing(TWEEN.Easing.Bounce.EaseOut).start();
        new TWEEN.Tween(this.position2).to({ y: GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2 }, 1400).easing(TWEEN.Easing.Bounce.EaseOut).start();
        new TWEEN.Tween(this.position3).to({ y: GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2 }, 1600).easing(TWEEN.Easing.Bounce.EaseOut).start();
        new TWEEN.Tween(this.position4).to({ y: GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2 }, 1800).easing(TWEEN.Easing.Bounce.EaseOut).start();
        new TWEEN.Tween(this.position5).to({ y: GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2 }, 2000).easing(TWEEN.Easing.Bounce.EaseOut).start();
        new TWEEN.Tween(this.position6).to({ y: GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2 }, 2200).easing(TWEEN.Easing.Bounce.EaseOut).start();
        new TWEEN.Tween(this.position7).to({ y: GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2 }, 2400).easing(TWEEN.Easing.Bounce.EaseOut).start();
        new TWEEN.Tween(this.position8).to({ y: GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2 }, 2600).easing(TWEEN.Easing.Bounce.EaseOut).start();
        new TWEEN.Tween(this.position9).to({ y: GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2 }, 2800).easing(TWEEN.Easing.Bounce.EaseOut).start();
        new TWEEN.Tween(this.position10).to({ y: (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) + 100 }, 4000).easing(TWEEN.Easing.Bounce.EaseOut).start();

        this.isPopup = true;

        this.draw = function (gameTime, context) {

            this.screenManager.fadeBackBufferToBlack(this.getTransitionAlpha() * 2 / 3);
            context.font = "30pt Calibri";
            context.textAlign = "center";
            context.fillStyle = "rgba(255,255,255," + this.getTransitionAlpha() + ")";

            context.fillText(gameOverPhrase[0], this.position0.x, this.position0.y);
            context.fillText(gameOverPhrase[1], this.position1.x, this.position1.y);
            context.fillText(gameOverPhrase[2], this.position2.x, this.position2.y);
            context.fillText(gameOverPhrase[3], this.position3.x, this.position3.y);
            context.fillText(gameOverPhrase[4], this.position4.x, this.position4.y);
            context.fillText(gameOverPhrase[5], this.position5.x, this.position5.y);
            context.fillText(gameOverPhrase[6], this.position6.x, this.position6.y);
            context.fillText(gameOverPhrase[7], this.position7.x, this.position7.y);
            context.fillText(gameOverPhrase[8], this.position8.x, this.position8.y);
            context.fillText(gameOverPhrase[9], this.position9.x, this.position9.y);

            context.fillText("Puntuación final: " + _score, this.position10.x, this.position10.y);

        };


        this.onAccepted = function (sender, eventArgs, object) {

            object.accepted.fire(this, null);
            object.exitScreen();

        };

        this.onCanceled = function (sender, eventArgs, object) {

            object.canceled.fire(this, null);
            object.exitScreen();

        };

        this.handleInput = function (inputState) {

            if (inputState.isNewKeyPress(COMMON.Keys.Enter)) {

                var youLoseMBox = new GAMESTATEMANAGEMENT.MessageBoxScreen("¿Reintentar?");
                youLoseMBox.accepted.subscribe(this, this.onAccepted);
                youLoseMBox.canceled.subscribe(this, this.onCanceled);

                this.screenManager.addScreen(youLoseMBox);
            }

        };

        var baseUpdate = this.update;
        this.update = function (gameTime, otherScreenHasFocus, coveredByOtherScreen) {

            TWEEN.update();

            timer++;

            if (timer > 200) {

                this.position0.y = (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) - (30 * Math.abs(Math.sin(gameTime.totalGameTime / 100)));
                this.position1.y = (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) - (30 * Math.abs(Math.sin((gameTime.totalGameTime / 100) - 10)));
                this.position2.y = (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) - (30 * Math.abs(Math.sin((gameTime.totalGameTime / 100) - 20)));
                this.position3.y = (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) - (30 * Math.abs(Math.sin((gameTime.totalGameTime / 100) - 30)));
                this.position4.y = (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) - (30 * Math.abs(Math.sin((gameTime.totalGameTime / 100) - 40)));
                this.position5.y = (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) - (30 * Math.abs(Math.sin((gameTime.totalGameTime / 100) - 50)));
                this.position6.y = (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) - (30 * Math.abs(Math.sin((gameTime.totalGameTime / 100) - 60)));
                this.position7.y = (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) - (30 * Math.abs(Math.sin((gameTime.totalGameTime / 100) - 70)));
                this.position8.y = (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) - (30 * Math.abs(Math.sin((gameTime.totalGameTime / 100) - 80)));
                this.position9.y = (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) - (30 * Math.abs(Math.sin((gameTime.totalGameTime / 100) - 90)));

            }

            baseUpdate.call(this, gameTime, otherScreenHasFocus, coveredByOtherScreen);
        };

    };

    GAMESTATEMANAGEMENT.GameOverScreen.prototype = new GAMESTATEMANAGEMENT.GameScreen();
    GAMESTATEMANAGEMENT.GameOverScreen.constructor = GAMESTATEMANAGEMENT.GameOverScreen;

    ///MessageBoxScreen.js
    GAMESTATEMANAGEMENT.MessageBoxScreen = function (text) {

        this.transitionOnTime = 100;
        this.transitionOffTime = 100;
        this.isPopup = true;
        this.isNoSelected = true;

        this.accepted = new COMMON.Event();
        this.canceled = new COMMON.Event();

        var prueba = 0;

        this.handleInput = function (inputState) {
            if (inputState.isNewKeyPress(COMMON.Keys.Up)) {
                if (!this.isNoSelected)
                    this.isNoSelected = true;
            }
            if (inputState.isNewKeyPress(COMMON.Keys.Down)) {
                if (this.isNoSelected)
                    this.isNoSelected = false;
            }
            if (inputState.isNewKeyPress(COMMON.Keys.Enter)) {
                this.exitScreen();
                this.isNoSelected ? this.canceled.fire(this, null) : this.accepted.fire(this, null);
            }
        };

        this.draw = function (gameTime, context) {

            this.screenManager.fadeBackBufferToBlack(this.getTransitionAlpha() * 2 / 3);
            context.font = "30pt Calibri";
            context.textAlign = "center";
            context.fillStyle = "rgba(255,255,255," + this.getTransitionAlpha() + ")";
            context.fillText(text, GAMESTATEMANAGEMENT.CANVAS_WIDTH / 2, GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2);

            context.font = "23pt Calibri";

            if (this.isNoSelected)
                context.fillStyle = "rgba(255,255,0," + this.getTransitionAlpha() + ")";
            else
                context.fillStyle = "rgba(255,255,255," + this.getTransitionAlpha() + ")"

            context.fillText("No", GAMESTATEMANAGEMENT.CANVAS_WIDTH / 2, (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) + 100);

            if (this.isNoSelected)
                context.fillStyle = "rgba(255,255,255," + this.getTransitionAlpha() + ")";
            else
                context.fillStyle = "rgba(255,255,0," + this.getTransitionAlpha() + ")";

            context.fillText("Sí", GAMESTATEMANAGEMENT.CANVAS_WIDTH / 2, (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) + 130);

        };

    };

    GAMESTATEMANAGEMENT.MessageBoxScreen.prototype = new GAMESTATEMANAGEMENT.GameScreen();
    GAMESTATEMANAGEMENT.MessageBoxScreen.constructor = GAMESTATEMANAGEMENT.MessageBoxScreen;

    ///CompanySplashScreen.js
    GAMESTATEMANAGEMENT.CompanySplashScreen = function () {

        this.transitionOnTime = 1000;
        this.transitionOffTime = 1000;
        var splashTimer;
        var nextScreenTimer;

        var position0 = { x: 0 };
        var position1 = { x: Math.PI / 2 };
        var position2 = { x: 0 };
        var position3 = { x: Math.PI * 1.5 };
        var position4 = { x: 0 };
        var position5 = { x: 0 };
        var position6 = { x: 0 };
        var position7 = { x: 0 };
        var position8 = { x: 0 };
        var position9 = { x: Math.PI / 2 };
        var position10 = { x: Math.PI / 2 };
        var position11 = { x: 0 };

        this.loadContent = function () {
            splashTimer = new GAMESTATEMANAGEMENT.Timer(this.screenManager);
            splashTimer.start(3000);
            nextScreenTimer = new GAMESTATEMANAGEMENT.Timer(this.screenManager);

            new TWEEN.Tween(position0).to({ x: 100 }, 1000).easing(TWEEN.Easing.Bounce.EaseOut).start();
            new TWEEN.Tween(position1).to({ x: Math.PI * 1.5 }, 2000).easing(TWEEN.Easing.Elastic.EaseOut).start();
            new TWEEN.Tween(position2).to({ x: 40 }, 1000).easing(TWEEN.Easing.Bounce.EaseInOut).start();
            new TWEEN.Tween(position3).to({ x: Math.PI }, 1000).easing(TWEEN.Easing.Linear.EaseNone).start();
            new TWEEN.Tween(position4).to({ x: 80 }, 1000).easing(TWEEN.Easing.Circular.EaseOut).start();
            new TWEEN.Tween(position5).to({ x: 100 }, 1000).easing(TWEEN.Easing.Circular.EaseInOut).start();
            new TWEEN.Tween(position6).to({ x: 50 }, 1000).easing(TWEEN.Easing.Sinusoidal.EaseIn).start();
            new TWEEN.Tween(position7).to({ x: 20 }, 1000).easing(TWEEN.Easing.Sinusoidal.EaseOut).start();
            new TWEEN.Tween(position8).to({ x: 100 }, 1000).easing(TWEEN.Easing.Quartic.EaseIn).start();
            new TWEEN.Tween(position9).to({ x: Math.PI * 1.5 }, 1000).easing(TWEEN.Easing.Quartic.EaseOut).start();
            new TWEEN.Tween(position10).to({ x: 0 }, 1000).easing(TWEEN.Easing.Quintic.EaseOut).start();
            new TWEEN.Tween(position11).to({ x: 1 }, 3000).easing(TWEEN.Easing.Exponential.EaseIn).start();

        };

        this.draw = function (gameTime, context) {

            context.save();
            context.translate((GAMESTATEMANAGEMENT.CANVAS_WIDTH / 2) - 140, (GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2) - 100);

            //R

            context.fillStyle = "black";
            context.lineWidth = 20;
            context.fillRect(30, 30, 20, position0.x);    // I

            context.beginPath();         //  )
            context.arc(50, 50, 30, position1.x, Math.PI / 2, false);
            context.stroke();

            context.fillRect(60, 90, 20, position2.x); //  \

            //A

            context.beginPath();  //Arco
            context.arc(150, 50, 30, position3.x, Math.PI * 1.5, false);
            context.stroke();

            context.fillRect(110, 50, 20, position4.x); //   /
            context.fillRect(150, 30, 20, position5.x); //  \ 

            context.fillRect(110, 70, position6.x, 20);  // --

            context.fillStyle = "white";
            context.fillRect(150, 70, position7.x, 20); // -

            //B
            context.fillStyle = "black";  //I
            context.fillRect(190, 30, 20, position8.x);
            context.beginPath();         //)
            context.arc(210, 50, 30, position9.x, Math.PI / 2, false);
            context.stroke();
                                       
            context.beginPath();         //)
            context.arc(210, 90, 30, position10.x, Math.PI / 2, false);
            context.stroke();

            context.fillStyle = "rgba(0,0,0," + position11.x + ")";
            context.font = "40pt Arial";
            context.fillText("GAMES", 40, 180);

            context.restore();

            this.screenManager.fadeBackBufferToBlack(1 - this.getTransitionAlpha());

            //            context.font = "30pt Calibri";
            //            context.textAlign = "center";
            //            context.fillStyle = "black";
            //            context.fillText("RAB GAMES", GAMESTATEMANAGEMENT.CANVAS_WIDTH / 2, GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2);
        };

        var baseUpdate = this.update;
        this.update = function (gameTime, otherScreenHasFocus, coveredByOtherScreen) {

            TWEEN.update();
            if (splashTimer.check()) {
                splashTimer.stop();
                nextScreenTimer.start(900);
                this.exitScreen();
            }

            if (nextScreenTimer.check()) {
                this.screenManager.addScreen(new GAMESTATEMANAGEMENT.TitleScreen());
                //this.screenManager.addScreen(new GAMESTATEMANAGEMENT.BackgroundScreen());
                //this.screenManager.addScreen(new GAMESTATEMANAGEMENT.MainMenuScreen());
            }
            baseUpdate.call(this, gameTime, otherScreenHasFocus, coveredByOtherScreen);
        };

    };

    GAMESTATEMANAGEMENT.CompanySplashScreen.prototype = new GAMESTATEMANAGEMENT.GameScreen();
    GAMESTATEMANAGEMENT.CompanySplashScreen.constructor = GAMESTATEMANAGEMENT.CompanySplashScreen;

    ///MenuScreen.js

    GAMESTATEMANAGEMENT.MenuScreen = function (menuTitle) {

        var y = 100;

        var _menuTitle = menuTitle;
        this.menuEntries = new Array();
        this.selectedEntry = 0;
        this.transitionOffTime = 100;
        this.transitionOnTime = 100;

        //document.body.menuScreen = this;
        //document.body.addEventListener("keydown", this.handleKeyboardInput, false);

        this.handleInput = function (inputState) {


            if (this.menuEntries[this.selectedEntry] instanceof GAMESTATEMANAGEMENT.NumericLeftRightMenuEntry) {
                if (inputState.isNewKeyPress(COMMON.Keys.Left)) {
                    this.menuEntries[this.selectedEntry].decrease();
                };

                if (inputState.isNewKeyPress(COMMON.Keys.Right)) {
                    this.menuEntries[this.selectedEntry].increase();
                };
            }

            if (inputState.isNewKeyPress(COMMON.Keys.Down)) //Abajo
            {
                //console.log("Abajo");
                this.selectedEntry = Math.min(this.menuEntries.length - 1, this.selectedEntry + 1);
            }
            else if (inputState.isNewKeyPress(COMMON.Keys.Up)) //Arriba
            {
                //console.log("Arriba");
                this.selectedEntry = Math.max(0, this.selectedEntry - 1);

            }
            else if (inputState.isNewKeyPress(COMMON.Keys.Enter)) //Enter
                this.selectCurrentEntry();

        };

        //virtual
        this.selectCurrentEntry = function () {

        };

        this.draw = function (gameTime, context) {

            context.font = "40pt Calibri";
            context.fillStyle = "rgba(255,255,255," + this.getTransitionAlpha() + ")";
            context.textAlign = "center";
            context.fillText(_menuTitle, GAMESTATEMANAGEMENT.CANVAS_WIDTH / 2, 45);


            //console.log(this.selectedEntry);

            for (var i = 0; i < this.menuEntries.length; i++) {

                this.menuEntries[i].isSelected = this.selectedEntry == i;
                this.menuEntries[i].position.x = GAMESTATEMANAGEMENT.CANVAS_WIDTH / 2;
                this.menuEntries[i].position.y = y + (i * 40);
                this.menuEntries[i].draw(this);
            }
        };

        this.loadContent = function () {


            for (var i = 0; i < this.menuEntries.length; i++)
                this.menuEntries[i].loadContent();
        }

        this.unloadContent = function () {

            for (var i = 0; i < this.menuEntries.length; i++)
                this.menuEntries[i].unloadContent();
        }

    };

    GAMESTATEMANAGEMENT.MenuScreen.prototype = new GAMESTATEMANAGEMENT.GameScreen();
    GAMESTATEMANAGEMENT.MenuScreen.constructor = GAMESTATEMANAGEMENT.MenuScreen;


    ///MainMenuScreen.js

    GAMESTATEMANAGEMENT.MainMenuScreen = function () {

        GAMESTATEMANAGEMENT.MenuScreen.call(this, "Menú principal");

        var onExit = function () {
            window.close();
        };

        var onPlayGame = function () {
        };

        var onOptions = function () {
        };

        this.selectCurrentEntry = function () {
            if (this.selectedEntry == 0) //Jugar
            {
                var gamePlayScreen = new Array();
                gamePlayScreen.push(new GAMESTATEMANAGEMENT.GameplayScreen());
                GAMESTATEMANAGEMENT.LoadingScreen.load(this.screenManager, true, gamePlayScreen);
            }
            else if (this.selectedEntry == 1) //Opciones
                this.screenManager.addScreen(new GAMESTATEMANAGEMENT.OptionsScreen());
            else if (this.selectedEntry == 2) //Salir
            {
                var confirmationBox = new GAMESTATEMANAGEMENT.MessageBoxScreen("¿Estás seguro?");
                confirmationBox.accepted.subscribe(this, this.close);

                this.screenManager.addScreen(confirmationBox);

            }
        };

        this.close = function () {
            window.open('', '_self', '');
            window.close();
        };

        this.menuEntries.push(new GAMESTATEMANAGEMENT.MenuEntry("Jugar"));
        //this.menuEntries.push(new GAMESTATEMANAGEMENT.MenuEntry("Opciones"));
        this.menuEntries.push(new GAMESTATEMANAGEMENT.MenuEntry("Salir"));

    };

    GAMESTATEMANAGEMENT.MainMenuScreen.prototype = new GAMESTATEMANAGEMENT.MenuScreen();
    GAMESTATEMANAGEMENT.MainMenuScreen.constructor = GAMESTATEMANAGEMENT.MainMenuScreen;


    ///PauseMenuScreen.js
    GAMESTATEMANAGEMENT.PauseMenuScreen = function () {

        GAMESTATEMANAGEMENT.MenuScreen.call(this, "Pausa");
        this.isPopup = true;

        this.transitionOffTime = 0;
        this.transitionOnTime = 0;

        this.onContinue = new COMMON.Event();
        this.onExit = new COMMON.Event();
        this.onRetry = new COMMON.Event();

        this.menuEntries.push(new GAMESTATEMANAGEMENT.MenuEntry("Continuar"));
        this.menuEntries.push(new GAMESTATEMANAGEMENT.MenuEntry("Reintentar"));
        this.menuEntries.push(new GAMESTATEMANAGEMENT.MenuEntry("Salir"));

        var baseDraw = this.draw;
        this.draw = function (gameTime, context) {
            this.screenManager.fadeBackBufferToBlack(this.getTransitionAlpha() * 2 / 3);
            baseDraw.call(this, gameTime, context);
        };

        this.exitAccepted = function (sender, eventArgs, object) {
            object.onExit.fire(this, null);
            object.exitScreen();
        };

        this.retryAccepted = function (sender, eventArgs, object) {
            object.onRetry.fire(this, null);
            object.exitScreen();
        };

        this.selectCurrentEntry = function () {
            if (this.selectedEntry == 0) {  //Continuar
                this.onContinue.fire(this, null);
                this.exitScreen();
            }
            else if (this.selectedEntry == 1) {  //Reintentar

                var confirmationBox = new GAMESTATEMANAGEMENT.MessageBoxScreen("¿Quieres reintentar?");

                window.pauseMenuScreen = this;
                confirmationBox.accepted.subscribe(this, this.retryAccepted);
                this.screenManager.addScreen(confirmationBox);
                
            }
            else if (this.selectedEntry == 2) {  //Salir

                var confirmationBox = new GAMESTATEMANAGEMENT.MessageBoxScreen("¿Quieres salir?");

                window.pauseMenuScreen = this;
                confirmationBox.accepted.subscribe(this, this.exitAccepted);
                this.screenManager.addScreen(confirmationBox);
            }
        };

    };

    GAMESTATEMANAGEMENT.PauseMenuScreen.prototype = new GAMESTATEMANAGEMENT.MenuScreen();
    GAMESTATEMANAGEMENT.PauseMenuScreen.constructor = GAMESTATEMANAGEMENT.PauseMenuScreen;

    ///OptionsScreen.js

    GAMESTATEMANAGEMENT.OptionsScreen = function () {

        GAMESTATEMANAGEMENT.MenuScreen.call(this, "Opciones");

        this.selectCurrentEntry = function () {
            if (this.selectedEntry == 2) {
                this.saveData();
                this.exitScreen();

            }

        };

        this.loadData = function () {

            var speed = this.screenManager.getSettingValue(SNAKEGAME.SETTINGKEY_SPEED);
            var level = this.screenManager.getSettingValue(SNAKEGAME.SETTINGKEY_LEVEL);

            if(speed != null)
                this.menuEntries[0].setValue(parseInt(speed));

            if (level != null)
                this.menuEntries[1].setValue(parseInt(level));
        };

        this.saveData = function () {

            this.screenManager.setSettingValue(SNAKEGAME.SETTINGKEY_SPEED, this.menuEntries[0].getValue());
            this.screenManager.setSettingValue(SNAKEGAME.SETTINGKEY_LEVEL, this.menuEntries[1].getValue());
        };

        //        this.menuEntries.push(new GAMESTATEMANAGEMENT.MenuEntry("Opción 1"));
        //        this.menuEntries.push(new GAMESTATEMANAGEMENT.MenuEntry("Opción 2"));
        //        this.menuEntries.push(new GAMESTATEMANAGEMENT.MenuEntry("Opción 3"));


        this.menuEntries.push(new GAMESTATEMANAGEMENT.NumericLeftRightMenuEntry("Velocidad", 0, 9));
        this.menuEntries.push(new GAMESTATEMANAGEMENT.NumericLeftRightMenuEntry("Laberinto", 0, 9));
        this.menuEntries.push(new GAMESTATEMANAGEMENT.MenuEntry("Regresar"));

        this.loadContent = function () {
            this.loadData();
        };



    };

    GAMESTATEMANAGEMENT.OptionsScreen.prototype = new GAMESTATEMANAGEMENT.MenuScreen();
    GAMESTATEMANAGEMENT.OptionsScreen.constructor = GAMESTATEMANAGEMENT.OptionsScreen;


    ///TitleScreen.js

    GAMESTATEMANAGEMENT.TitleScreen = function () {

        this.transitionOnTime = 500;
        this.transitionOffTime = 500;
        var prueba = 0;
        var grd;

        var imageObj;

        //        this.loadContent = function () {
        //            grd = this.screenManager.context.createRadialGradient(238, 50, 10, 238, 50, 200);
        //            grd.addColorStop(0, "#8ED6FF"); // light blue
        //            grd.addColorStop(1, "#004CB3"); // dark blue
        //        };

        this.loadContent = function () {

            imageObj = new Image();
            imageObj.onload = function () {

            };
            imageObj.src = "b1.png";
        }

        this.draw = function (gameTime, context) {

 
            //context.fillStyle = "red";
            //context.fillRect(0, 0, GAMESTATEMANAGEMENT.CANVAS_WIDTH, GAMESTATEMANAGEMENT.CANVAS_HEIGHT);

            context.drawImage(imageObj, 0, 0);

            context.font = "23pt Calibri";
            context.fillStyle = "rgba(255,255,255," + Math.abs(Math.sin((gameTime.totalGameTime / 1000) * 3)) + ")";
            context.textAlign = "center";
            context.fillText("Presiona ENTER", GAMESTATEMANAGEMENT.CANVAS_WIDTH / 2, GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2 + 100);

            context.font = "40pt Calibri";
            context.fillStyle = "white";
            context.textAlign = "center";
            context.fillText("PUZZLE BOBBLE", GAMESTATEMANAGEMENT.CANVAS_WIDTH / 2, GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2 - 40);

            this.screenManager.fadeBackBufferToBlack(1 - this.getTransitionAlpha());

        };

        this.handleInput = function (inputState) {

            if (inputState.isNewKeyPress(COMMON.Keys.Enter)) {
                this.exitScreen();
                this.screenManager.addScreen(new GAMESTATEMANAGEMENT.BackgroundScreen());
                this.screenManager.addScreen(new GAMESTATEMANAGEMENT.MainMenuScreen());
            }

        };

    };

    GAMESTATEMANAGEMENT.TitleScreen.prototype = new GAMESTATEMANAGEMENT.GameScreen();
    GAMESTATEMANAGEMENT.TitleScreen.constructor = GAMESTATEMANAGEMENT.TitleScreen;


    ///LoadingScreen.js //Se debe utilizar el método estático LOAD, no instanciar directamente

    GAMESTATEMANAGEMENT.LoadingScreen = function (loadingIsSlow, screensToLoad) {

        var _loadingIsSlow = loadingIsSlow;
        var _otherScreensAreGone;
        var _screensToLoad = screensToLoad;

        this.transitionOnTime = 500;
        this.transitionOffTime = 500;

        var baseUpdate = this.update;

        this.update = function (gameTime, otherScreenHasFocus, coveredByOtherScreen) {

            baseUpdate.call(this, gameTime, otherScreenHasFocus, coveredByOtherScreen);

            //console.log("update");

            if (_otherScreensAreGone) {
                this.screenManager.removeScreen(this);

                for (var i = 0; i < _screensToLoad.length; i++) {
                    if (_screensToLoad[i] != null) {
                        this.screenManager.addScreen(_screensToLoad[i]);
                    }
                }

                // Once the load has finished, we use ResetElapsedTime to tell
                // the  game timing mechanism that we have just finished a very
                // long frame, and that it should not try to catch up.
                //ScreenManager.Game.ResetElapsedTime();
            }
        };

        this.draw = function (gameTime, context) {


            if ((this.screenState == GAMESTATEMANAGEMENT.ScreenState.Active) &&
                (this.screenManager.getScreenCount() == 1)) {
                //console.log(this.screenManager.getScreens());
                _otherScreensAreGone = true;
            }

            if (_loadingIsSlow) {
                context.fillStyle = "black";
                context.fillRect(0, 0, GAMESTATEMANAGEMENT.CANVAS_WIDTH, GAMESTATEMANAGEMENT.CANVAS_HEIGHT);
                context.font = "23pt Calibri";
                context.fillStyle = "white";
                context.fillText("Cargando...", GAMESTATEMANAGEMENT.CANVAS_WIDTH / 2, GAMESTATEMANAGEMENT.CANVAS_HEIGHT / 2);
            }

        };

    };

    GAMESTATEMANAGEMENT.LoadingScreen.prototype = new GAMESTATEMANAGEMENT.GameScreen();
    GAMESTATEMANAGEMENT.LoadingScreen.constructor = GAMESTATEMANAGEMENT.LoadingScreen;
    
    //static
    GAMESTATEMANAGEMENT.LoadingScreen.load = function (screenManager, loadingIsSlow, screensToLoad) {

        var screens = screenManager.getScreens();

        for(var i=0; i < screens.length; i++)
        {   
            screens[i].exitScreen();
        }

        var loadingScreen = new GAMESTATEMANAGEMENT.LoadingScreen(loadingIsSlow, screensToLoad);
        screenManager.addScreen(loadingScreen);
    };


    ///GameplayScreen.js
    GAMESTATEMANAGEMENT.GameplayScreen = function () {


        this.transitionOnTime = 500;
        this.transitionOffTime = 500;

        var _isPaused = false;

        var puzzleBobbleGame;

        this.loadContent = function () {

            puzzleBobbleGame = new PUZZLEBOBBLEGAME.PuzzleBobbleGame(this);
            puzzleBobbleGame.onLose.subscribe(this, this.onGameOver);
            puzzleBobbleGame.reset();
        };

        this.draw = function (gameTime, context) {

            puzzleBobbleGame.draw(gameTime, context);
        };

        var baseUpdate = this.update;
        this.update = function (gameTime, otherScreenHasFocus, coveredByOtherScreen) {

            if (!_isPaused) {
                puzzleBobbleGame.update(gameTime);
                baseUpdate.call(this, gameTime, otherScreenHasFocus, coveredByOtherScreen);
            }
        };

        this.onRetry = function () {
            _isPaused = false;
            puzzleBobbleGame.reset();
        };

        this.onContinue = function () {
            _isPaused = false;
        };


        this.onGameOver = function (sender, eventArgs, object) {

            _isPaused = true;


            var gameOverScreen = new GAMESTATEMANAGEMENT.GameOverScreen(puzzleBobbleGame.getScore());
            gameOverScreen.accepted.subscribe(object, object.onRetry);
            gameOverScreen.canceled.subscribe(object, object.onExit);

            object.screenManager.addScreen(gameOverScreen);

        };

        this.onExit = function (sender, eventArgs, object) {


            object.exitScreen();
            object.screenManager.addScreen(new GAMESTATEMANAGEMENT.BackgroundScreen());
            object.screenManager.addScreen(new GAMESTATEMANAGEMENT.MainMenuScreen());
            _isPaused = false;
        };

        this.handleInput = function (inputState) {

            if (inputState.isNewKeyPress(COMMON.Keys.Enter)) {          //Pausa

                _isPaused = true;

                var pauseMenuScreen = new GAMESTATEMANAGEMENT.PauseMenuScreen();
                pauseMenuScreen.onContinue.subscribe(this, this.onContinue);
                pauseMenuScreen.onRetry.subscribe(this, this.onRetry);
                pauseMenuScreen.onExit.subscribe(this, this.onExit);

                this.screenManager.addScreen(pauseMenuScreen);
            }

            if (inputState.isKeyDown(COMMON.Keys.Left)) {
                puzzleBobbleGame.moveCannonLeft();
            }
            if (inputState.isKeyDown(COMMON.Keys.Right)) {
                puzzleBobbleGame.moveCannonRight();
            }
            if (inputState.isKeyDown(COMMON.Keys.Up)) {
                puzzleBobbleGame.fireBubble();
            }

        };

    };

    GAMESTATEMANAGEMENT.GameplayScreen.prototype = new GAMESTATEMANAGEMENT.GameScreen();
    GAMESTATEMANAGEMENT.GameplayScreen.constructor = GAMESTATEMANAGEMENT.GameplayScreen;


    /////////////////// PUZZLE BOBBLE GAME

    var bubbleShineGradValue = 0;

    PUZZLEBOBBLEGAME.PuzzleBobbleGame = function (parentScreen) {

        var blackeningTimer = 0;
        var blackeningCounter = 0;
        var bubbleShineTimer = 0;
        var nextBubbleBounce = 0;
        var bubblesTrembling = 0;
        var bubblesTremblingTimer = 0;
        var _parentScreen = parentScreen;
        this.onLose = new COMMON.Event();
        var isLost = false;

        var cannon;
        var currentBubble;
        var nextBubble;

        var _score = 0;
        var bubblesOddEven;
        var addingNewRow = false;
        var addRowTimer = 0;
        var currentBubbleIsBeingFired = false;
        var bubbles;
        var guideBubble;



        this.reset = function () {

            isLost = false;
            _score = 0;
            cannon = new PUZZLEBOBBLEGAME.Cannon(((PUZZLEBOBBLEGAME.FIELD_ENDX - PUZZLEBOBBLEGAME.FIELD_STARTX) / 2) + 25, PUZZLEBOBBLEGAME.FIELD_STARTY + PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE * 10);
            guideBubble = new PUZZLEBOBBLEGAME.Bubble(((PUZZLEBOBBLEGAME.FIELD_ENDX - PUZZLEBOBBLEGAME.FIELD_STARTX) / 2) + 25, PUZZLEBOBBLEGAME.FIELD_STARTY + PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE * 10, 1);

            currentBubble = new PUZZLEBOBBLEGAME.Bubble(((PUZZLEBOBBLEGAME.FIELD_ENDX - PUZZLEBOBBLEGAME.FIELD_STARTX) / 2) + 25, PUZZLEBOBBLEGAME.FIELD_STARTY + PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE * 10, Math.floor(Math.random() * 4));
            nextBubble = new PUZZLEBOBBLEGAME.Bubble(((PUZZLEBOBBLEGAME.FIELD_ENDX - PUZZLEBOBBLEGAME.FIELD_STARTX) / 2) - 50, PUZZLEBOBBLEGAME.FIELD_STARTY + PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE * 10, Math.floor(Math.random() * 4));
            bubblesOddEven = new Array();
            bubbles = new Array();

            blackeningTimer = 0;
            blackeningCounter = 0;
            bubbleShineTimer = 0;
            nextBubbleBounce = 0;
            bubblesTrembling = 0;
            bubblesTremblingTimer = 0;

            addingNewRow = false;
            addRowTimer = 0;
            currentBubbleIsBeingFired = false;
            initGameField();

        };

        this.getScore = function () {
            return _score;
        };

        function initGameField() {

            var randomType = 0;

            for (var i = 0; i < 6; i++) {

                if (i % 2 == 0)
                    bubblesOddEven.push(0);
                else
                    bubblesOddEven.push(1);

                for (var j = 0; j < 10; j++) {

                    randomType = Math.floor(Math.random() * 4);
                    if (i % 2 == 0)
                        bubbles.push(new PUZZLEBOBBLEGAME.Bubble(PUZZLEBOBBLEGAME.FIELD_STARTX + (j * PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2), PUZZLEBOBBLEGAME.FIELD_STARTY + (i * PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE), randomType));          //Math.floor(Math.random() * 4)
                    else {
                        if (j < 9)
                            bubbles.push(new PUZZLEBOBBLEGAME.Bubble(PUZZLEBOBBLEGAME.FIELD_STARTX + (PUZZLEBOBBLEGAME.BUBBLE_RADIO) + (j * PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2), PUZZLEBOBBLEGAME.FIELD_STARTY + (i * PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE), randomType));   //Math.floor(Math.random() * 4)
                    }
                }
            }

        };

        function startAddTopRow() {

            addingNewRow = true;
            addRowTimer = 0;

        }

        function checkLose() {

            for (var i = 0; i < bubbles.length; i++) {
                var row = Math.round((bubbles[i].getY() - PUZZLEBOBBLEGAME.FIELD_STARTY) / (PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE));

                if (row == 10) {
                    isLost = true;
                    break;
                }

            }

        }

        function addTopRow() {

            //baja todas las burbujas actuales para hacer espacio a las nuevas burbujas
            for (var i = 0; i < bubbles.length; i++) {
                bubbles[i].setY(bubbles[i].getY() + PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE);
            }

            var oddEven = bubblesOddEven[0];

            if (oddEven == 1) {
                oddEven = 0;
                bubblesOddEven.splice(0, 0, 0);
            }
            else {
                oddEven = 1;
                bubblesOddEven.splice(0, 0, 1);
            }

            //agrega nuevas burbujas
            for (var i = 0; i < 10; i++) {

                if (oddEven == 1) {
                    if (i < 9)
                        bubbles.push(new PUZZLEBOBBLEGAME.Bubble(PUZZLEBOBBLEGAME.FIELD_STARTX + (i * PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2) + (PUZZLEBOBBLEGAME.BUBBLE_RADIO * oddEven), PUZZLEBOBBLEGAME.FIELD_STARTY, Math.floor(Math.random() * 4)));
                }
                else {
                    bubbles.push(new PUZZLEBOBBLEGAME.Bubble(PUZZLEBOBBLEGAME.FIELD_STARTX + (i * PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2) + (PUZZLEBOBBLEGAME.BUBBLE_RADIO * oddEven), PUZZLEBOBBLEGAME.FIELD_STARTY, Math.floor(Math.random() * 4)));

                }
            }

            checkLose();
            //console.log(bubblesOddEven);
        }



        this.drawGameField = function (context) {

            context.strokeStyle = "white";
            context.lineWidth = 2;

            for (var i = 0; i < 9; i++) {
                for (var j = 0; j < 10; j++) {

                    context.beginPath();
                    if (i % 2 == 0) {
                        context.arc(PUZZLEBOBBLEGAME.FIELD_STARTX + PUZZLEBOBBLEGAME.BUBBLE_RADIO + j * PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2, PUZZLEBOBBLEGAME.FIELD_STARTY + PUZZLEBOBBLEGAME.BUBBLE_RADIO + i * PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE, PUZZLEBOBBLEGAME.BUBBLE_RADIO, 0, 2 * Math.PI, false);
                    }
                    else {
                        if (j < 9)
                            context.arc(PUZZLEBOBBLEGAME.FIELD_STARTX + PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2 + j * PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2, PUZZLEBOBBLEGAME.FIELD_STARTY + PUZZLEBOBBLEGAME.BUBBLE_RADIO + i * PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE, PUZZLEBOBBLEGAME.BUBBLE_RADIO, 0, 2 * Math.PI, false);
                    }
                    context.stroke();
                }
            }

        };

        this.drawBackground = function (context) {

            context.fillStyle = "green";
            context.fillRect(0, 0, GAMESTATEMANAGEMENT.CANVAS_WIDTH, GAMESTATEMANAGEMENT.CANVAS_HEIGHT);

            context.save();

            context.beginPath();
            context.moveTo(PUZZLEBOBBLEGAME.FIELD_STARTX, PUZZLEBOBBLEGAME.FIELD_STARTY);
            context.lineTo(PUZZLEBOBBLEGAME.FIELD_ENDX, PUZZLEBOBBLEGAME.FIELD_STARTY);
            context.lineTo(PUZZLEBOBBLEGAME.FIELD_ENDX, PUZZLEBOBBLEGAME.FIELD_ENDY);
            context.lineTo(PUZZLEBOBBLEGAME.FIELD_STARTX, PUZZLEBOBBLEGAME.FIELD_ENDY);
            context.closePath();
            context.clip();

            context.fillStyle = "rgb(59,97,252)";
            context.fillRect(0, 0, GAMESTATEMANAGEMENT.CANVAS_WIDTH, GAMESTATEMANAGEMENT.CANVAS_HEIGHT);
            context.lineWidth = 1;
            context.strokeStyle = "white";

            for (var i = 0; i < GAMESTATEMANAGEMENT.CANVAS_HEIGHT; i += PUZZLEBOBBLEGAME.FIELD_TILE_HEIGHT) {
                context.moveTo(0, i);
                context.lineTo(GAMESTATEMANAGEMENT.CANVAS_WIDTH, i);
                context.stroke();
            }

            for (var i = 0; i < GAMESTATEMANAGEMENT.CANVAS_WIDTH; i += PUZZLEBOBBLEGAME.FIELD_TILE_WIDTH) {
                context.moveTo(i, 0);
                context.lineTo(i, GAMESTATEMANAGEMENT.CANVAS_HEIGHT);
                context.stroke();
            }

            context.restore();


            context.lineWidth = 1;
            context.strokeStyle = "white";
            context.moveTo(PUZZLEBOBBLEGAME.FIELD_STARTX, PUZZLEBOBBLEGAME.FIELD_STARTY + (PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE * 10));
            context.lineTo(PUZZLEBOBBLEGAME.FIELD_ENDX, PUZZLEBOBBLEGAME.FIELD_STARTY + (PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE * 10));
            context.stroke();


        }


        this.drawHud = function (context) {

            context.font = PUZZLEBOBBLEGAME.SCORE_FONT;
            context.fillStyle = "white";
            context.fillText(pad(_score, 10), PUZZLEBOBBLEGAME.SCORE_POSITIONX, PUZZLEBOBBLEGAME.SCORE_POSITIONY);
        };

        function pad(number, length) {

            var str = '' + number;
            while (str.length < length) {
                str = '0' + str;
            }

            return str;

        }

        this.update = function (gameTime) {

            if (isLost) {

                if (blackeningCounter < bubbles.length) {

                    bubblesTrembling = 5 * Math.sin(gameTime.totalGameTime);
                    if (blackeningTimer < 100)
                        blackeningTimer += gameTime.totalGameTime;
                    else {
                        bubbles[blackeningCounter].blacken();

                        blackeningTimer = 0;
                        blackeningCounter++;
                        if (blackeningCounter == bubbles.length)
                            this.onLose.fire(this, null);
                    }
                }

                return;
            }


            if (addRowTimer < 10000) {
                addRowTimer += gameTime.elapsedGameTime;
                bubblesTrembling = 0;
            }
            else {


                if (bubblesTremblingTimer < 1000) {
                    bubblesTrembling = 5 * Math.sin(gameTime.totalGameTime);
                    bubblesTremblingTimer += gameTime.elapsedGameTime;
                }
                else {
                    bubblesTrembling = 0;
                    bubblesTremblingTimer = 0;
                    addTopRow();
                    addRowTimer = 0;
                }
            }

            if (nextBubbleBounce < 1) {
                nextBubbleBounce += 0.01;
                BounceEaseOut(nextBubbleBounce);
                nextBubble.setX(250 * BounceEaseOut(nextBubbleBounce) - 50);
            }

            if (bubbleShineTimer < 2000) {
                bubbleShineTimer += gameTime.elapsedGameTime;
            }

            else {

                bubbleShineGradValue += 0.01;

                if (bubbleShineGradValue >= 0.6) {
                    bubbleShineGradValue = 0;
                    bubbleShineTimer = 0;
                }
            }

            currentBubble.update(gameTime);
            nextBubble.update(gameTime);


            if (currentBubble.getX() + PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2 > PUZZLEBOBBLEGAME.FIELD_ENDX && currentBubble.getVx() > 0 || currentBubble.getX() < PUZZLEBOBBLEGAME.FIELD_STARTX && currentBubble.getVx() < 0)
                currentBubble.inverseVx();

            if (currentBubble.getY() < PUZZLEBOBBLEGAME.FIELD_STARTY && currentBubble.getVy() < 0) {
                adjustToNearestCell();
                bubbles.push(currentBubble);
                getBubbleChainRec(bubbles[bubbles.length - 1]);
                getUnchainedBubblesRec();
                loadBubbleIntoCannon();


            }
            else {

                for (var i = 0; i < bubbles.length; i++) {
                    if (!bubbles[i].isDying()) {

                        if (currentBubbleIsBeingFired) {
                            if (currentBubble.collides(bubbles[i])) {
                                adjustToNearestCell();
                                bubbles.push(currentBubble);
                                getBubbleChainRec(bubbles[bubbles.length - 1]);
                                getUnchainedBubblesRec();
                                loadBubbleIntoCannon();
                                checkLose();
                                break;
                            }
                        }
                    }
                }
            }


            for (var i = 0; i < bubbles.length; i++) {
                bubbles[i].update(gameTime);
                if (bubbles[i].getY() > GAMESTATEMANAGEMENT.CANVAS_HEIGHT) {       //Las burbujas desaparecen cuando se salen del nivel por abajo
                    bubbles.splice(i, 1);
                    i--;
                }

                else if (bubbles[i].getRadio() <= 0) {
                    bubbles.splice(i, 1);
                    i--;
                }

            }

            //            var collides = false;

            //            guideBubble.setVx(PUZZLEBOBBLEGAME.BUBBLE_SPEED * Math.cos(cannon.getRotationAngle()));
            //            guideBubble.setVy(PUZZLEBOBBLEGAME.BUBBLE_SPEED * Math.sin(cannon.getRotationAngle()));
            //            
            //            guideBubble.update();

            //guideBubble.setX(guideBubble.getX() + x);
            //guideBubble.setY(guideBubble.getY() + y);

            //guideBubble.setX(0);
            //guideBubble.setY(50);

            //            var collides = false;

            //            //            //            //x += x * 10;
            //            //            //            //y += y * 10;


            //            while (!collides) {

            //                guideBubble.update();

            //                for (var i = 0; i < bubbles.length; i++) {
            //                    if (!bubbles[i].isDying()) {
            //                        if (guideBubble.collides(bubbles[i])) {
            //                            collides = true;
            //                            break;
            //                        }
            //                    }
            //                }
            //            }



        };

        function loadBubbleIntoCannon() {

            currentBubble = nextBubble;
            currentBubble.setX(((PUZZLEBOBBLEGAME.FIELD_ENDX - PUZZLEBOBBLEGAME.FIELD_STARTX) / 2) + 25);
            currentBubble.setY(PUZZLEBOBBLEGAME.FIELD_STARTY + PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE * 10);

            nextBubble = new PUZZLEBOBBLEGAME.Bubble(((PUZZLEBOBBLEGAME.FIELD_ENDX - PUZZLEBOBBLEGAME.FIELD_STARTX) / 2) - 50, PUZZLEBOBBLEGAME.FIELD_STARTY + PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE * 10, Math.floor(Math.random() * 4));
            nextBubbleBounce = 0;
            currentBubbleIsBeingFired = false;
        }

        function adjustToNearestCell() {

            currentBubble.setVx(0);
            currentBubble.setVy(0);

            var row = Math.round((currentBubble.getY() - PUZZLEBOBBLEGAME.FIELD_STARTY) / (PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE));
            currentBubble.setY(PUZZLEBOBBLEGAME.FIELD_STARTY + (row * PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE));

            if (row == 0) {

                if (bubblesOddEven[0] == 1) {
                    var col = Math.round((currentBubble.getX() - PUZZLEBOBBLEGAME.FIELD_STARTX - PUZZLEBOBBLEGAME.BUBBLE_RADIO) / (PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2));
                    currentBubble.setX((PUZZLEBOBBLEGAME.FIELD_STARTX + (col * PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2)) + PUZZLEBOBBLEGAME.BUBBLE_RADIO);
                }
                else {
                    var col = Math.round((currentBubble.getX() - PUZZLEBOBBLEGAME.FIELD_STARTX) / (PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2));
                    currentBubble.setX(PUZZLEBOBBLEGAME.FIELD_STARTX + (col * PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2));
                }

            }
            else if (bubblesOddEven[row - 1] == 1) {

                if (bubblesOddEven.length == row)
                    bubblesOddEven.push(0);

                var col = Math.round((currentBubble.getX() - PUZZLEBOBBLEGAME.FIELD_STARTX) / (PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2));
                currentBubble.setX(PUZZLEBOBBLEGAME.FIELD_STARTX + (col * PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2));
            }
            else {

                if (bubblesOddEven.length == row)
                    bubblesOddEven.push(1);

                var col = Math.round((currentBubble.getX() - PUZZLEBOBBLEGAME.FIELD_STARTX - PUZZLEBOBBLEGAME.BUBBLE_RADIO) / (PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2));
                currentBubble.setX((PUZZLEBOBBLEGAME.FIELD_STARTX + (col * PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2)) + PUZZLEBOBBLEGAME.BUBBLE_RADIO);
            }
        }

        function getBubbleChain(bubble, bubbleChainArray) {

            bubbleChainArray.push(bubble);

            var b = false;
            for (var i = 0; i < bubbles.length; i++) {
                if (bubbles[i] != bubble) {

                    b = false;
                    for (var j = 0; j < bubbleChainArray.length; j++) {
                        if (bubbles[i] == bubbleChainArray[j]) {
                            b = true;
                            break;
                        }
                    }

                    if (!b) {
                        var distanceX = bubble.getX() - bubbles[i].getX();
                        var distanceY = bubble.getY() - bubbles[i].getY();

                        if (Math.round(Math.sqrt((distanceX * distanceX + distanceY * distanceY))) <= (PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2)) {
                            if (bubble.getType() == bubbles[i].getType())
                                getBubbleChain(bubbles[i], bubbleChainArray);
                        }
                    }
                }
            }

        };

        function getBubbleChainRec(bubble) {
            var bubbleChain = new Array();
            getBubbleChain(bubble, bubbleChain);

            if (bubbleChain.length >= 3) {
                _score += 100 + ((bubbleChain.length - 3) * 25);
                for (var i = 0; i < bubbleChain.length; i++) {
                    bubbleChain[i].startBreaking();
                }
            }


            return bubbleChain;
        }


        function BounceEaseOut(a) { return (a /= 1) < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375 };

        function getUnchainedBubblesRec() {

            var unchainedBubbles = new Array(); //Contiene únicamente las burbujas no conectadas
            var connectedBubbles = new Array(); //necesitamos saber cuales son las burbujas conectadas para poder saber cuales son las no conectadas
            var currentChain; //La cadena escaneada actualmente

            var connected = false;
            var alreadyScanned;

            //alert(bubbles.length);

            for (var i = 0; i < bubbles.length; i++) {

                if (bubbles[i].isDying()) continue;

                alreadyScanned = false;

                //Checa que la burbuja no se haya detectado ya como desconectada
                for (var j = 0; j < unchainedBubbles.length; j++) {
                    if (unchainedBubbles[j] == bubbles[i]) {
                        alreadyScanned = true;
                        break;
                    }
                }

                //Checa que la burbuja no se haya detectado ya como conectada
                for (var j = 0; j < connectedBubbles.length; j++) {
                    if (connectedBubbles[j] == bubbles[i]) {
                        alreadyScanned = true;
                        break;
                    }
                }

                if (alreadyScanned)
                    continue;

                currentChain = new Array();
                getUnchainedBubbles(bubbles[i], currentChain, unchainedBubbles, connectedBubbles);

                connected = false;
                for (var j = 0; j < currentChain.length; j++) {
                    if (Math.round((currentChain[j].getY() - PUZZLEBOBBLEGAME.FIELD_STARTY) / (PUZZLEBOBBLEGAME.BUBBLE_VDISTANCE)) == 0) {
                        connected = true;
                        break;
                    }
                }

                if (!connected) {
                    for (var j = 0; j < currentChain.length; j++) {
                        unchainedBubbles.push(currentChain[j]);
                    }
                }
                else {
                    for (var j = 0; j < currentChain.length; j++) {
                        connectedBubbles.push(currentChain[j]);
                    }
                }

            }

            for (var i = 0; i < unchainedBubbles.length; i++) {
                unchainedBubbles[i].startFalling();
                _score += 100;
            }

            return unchainedBubbles;

        };

        function getUnchainedBubbles(bubble, currentChain, unchainedBubbles, connectedBubbles) {
            //Las burbujas no encadenadas son aquellas que no están conectadas directa o indirectamente con una burbuja de la primera fila


            currentChain.push(bubble);
            var b;

            for (var i = 0; i < bubbles.length; i++) {

                if (bubbles[i].isDying()) continue;

                if (bubbles[i] != bubble) {

                    b = false;
                    for (var j = 0; j < currentChain.length; j++) {
                        if (bubbles[i] == currentChain[j]) {
                            b = true;
                            break;
                        }
                    }


                    if (!b) {

                        var distanceX = bubble.getX() - bubbles[i].getX();
                        var distanceY = bubble.getY() - bubbles[i].getY();

                        if (Math.round(Math.sqrt((distanceX * distanceX + distanceY * distanceY))) <= (PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2)) {
                            getUnchainedBubbles(bubbles[i], currentChain, unchainedBubbles, connectedBubbles);
                        }
                    }
                }
            }


        };

        this.moveCannonRight = function () {
            cannon.moveRight();
        };

        this.moveCannonLeft = function () {
            cannon.moveLeft();
        };

        this.fireBubble = function () {

            if (!currentBubbleIsBeingFired) {
                currentBubbleIsBeingFired = true;
                currentBubble.setVx(PUZZLEBOBBLEGAME.BUBBLE_SPEED * Math.cos(cannon.getRotationAngle()));
                currentBubble.setVy(PUZZLEBOBBLEGAME.BUBBLE_SPEED * Math.sin(cannon.getRotationAngle()));
            }

        };


        this.draw = function (gameTime, context) {

            this.drawBackground(context);
            this.drawHud(context);
            //this.drawGameField(context);
            cannon.draw(gameTime, context);
            currentBubble.draw(gameTime, context, 0);
            for (var i = 0; i < bubbles.length; i++) {
                bubbles[i].draw(gameTime, context, bubblesTrembling);
            }
            nextBubble.draw(gameTime, context, 0);
            //guideBubble.draw(gameTime, context, 0);
        };

    };

    PUZZLEBOBBLEGAME.Bubble = function (x, y, type) {

        var _x = x || 0;
        var _y = y || 0;
        var _isFired = false;
        var _isDying = false;
        var _vx = 0;
        var _vy = 0;
        var _type = type || 0;
        var _radio = PUZZLEBOBBLEGAME.BUBBLE_RADIO;
        var _vradio = 0;
        var _isBlackened = false;

        this.getType = function () {
            return _type;
        };

        this.getX = function () {
            return _x;
        };

        this.getY = function () {
            return _y;
        };

        this.setX = function (x) {
            _x = x;
        };

        this.setY = function (y) {
            _y = y;
        };

        this.inverseVx = function () {
            _vx = -_vx;
        };

        this.inverseVy = function () {
            _vy = -_vy;
        };

        this.getVx = function () {
            return _vx;
        };

        this.getVy = function () {
            return _vy;
        };

        this.getRadio = function () {
            return _radio;
        };

        this.setVx = function (vx) {
            _vx = vx;
        };

        this.setVy = function (vy) {
            _vy = vy;
        };

        this.blacken = function()
        {
            _isBlackened = true;
        };

        this.collides = function (otherBubble) {
            var distanceX = otherBubble.getX() - _x;
            var distanceY = otherBubble.getY() - _y;

            return Math.sqrt(distanceX * distanceX + distanceY * distanceY) <= ((PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2) - 5);
        }

        this.draw = function (gameTime, context, xOffset) {

            context.beginPath();
            context.strokeStyle = "white";
            context.lineWidth = 2;
            context.arc(_x + PUZZLEBOBBLEGAME.BUBBLE_RADIO + xOffset, _y + PUZZLEBOBBLEGAME.BUBBLE_RADIO, _radio, 0, 2 * Math.PI, false);


            if(!_isBlackened)
            {
                switch (_type) {
                    case 0:
                        color = "red";
                        //context.fillStyle = "red";
                        break;
                    case 1:
                        color = "blue";
                        //context.fillStyle = "blue";
                        break;
                    case 2:
                        color = "green";
                        //context.fillStyle = "green";
                        break;
                    case 3:
                        color = "orange";
                        //context.fillStyle = "yellow";
                        break;
                }

                var grd = context.createLinearGradient(_x - 50, _y - 50, _x + 50 + (PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2), 50 + (_y + PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2));
                grd.addColorStop(bubbleShineGradValue, color);
                grd.addColorStop(bubbleShineGradValue + 0.2, "white"); // light blue
                grd.addColorStop(bubbleShineGradValue + 0.4, color);
                context.fillStyle = grd;
            }

            else
                context.fillStyle = "black";

            context.fill();
            context.stroke();
        };

        this.update = function (gameTime) {
            _x += _vx;
            _y += _vy;
            _radio += _vradio;
        };

        this.startFalling = function () {

            _vx = 0;
            _vy = 10;
            _isDying = true;
        };

        this.startBreaking = function () {
            _vx = 0;
            _vy = 0;
            _vradio = -1;
            _isDying = true;
        };

        this.isDying = function () {
            return _isDying;
        };

        



    };

    PUZZLEBOBBLEGAME.Cannon = function (x, y) {

        var _x = x || 0;
        var _y = y || 0;
        var _angle = -Math.PI / 2; //ángulo de inicio (cañón apuntando hacia arriba) (el cañon hay que dibujarlo apuntando hacia la derecha)
    

        this.draw = function (gameTime, context) {

            context.save();

            context.translate(_x + 25, _y + 25);
            context.rotate(_angle);
            context.beginPath();

            context.moveTo(25, -25);
            context.lineTo(-25, -25);
            context.lineTo(-25, 25);
            context.lineTo(25, 25);

            context.strokeStyle = "black";
            context.lineWidth = 5;
            context.stroke();
            context.restore();

            context.lineWidth = 2;
            context.beginPath();
            context.strokeStyle = "white";

           

            //            context.arc(_x + PUZZLEBOBBLEGAME.BUBBLE_RADIO + x, _y + PUZZLEBOBBLEGAME.BUBBLE_RADIO + y, PUZZLEBOBBLEGAME.BUBBLE_RADIO, 0, 2 * Math.PI, false);
            //            context.stroke();


            //            this.collides = function (otherBubble) {
            //            var distanceX = otherBubble.getX() - _x;
            //            var distanceY = otherBubble.getY() - _y;

            //            return Math.sqrt(distanceX * distanceX + distanceY * distanceY) <= ((PUZZLEBOBBLEGAME.BUBBLE_RADIO * 2) - 5);
            //        }

            //        this.draw = function (gameTime, context, xOffset) {

            //            context.beginPath();
            //            context.strokeStyle = "white";
            //            context.lineWidth = 2;

            //var x = PUZZLEBOBBLEGAME.BUBBLE_SPEED * Math.cos(_angle));
            //var y = PUZZLEBOBBLEGAME.BUBBLE_SPEED * Math.sin(_angle));




            //            var guideStartingX = _x + 25 + (Math.cos(_angle) * 50);
            //            var guideStartingY = _y + 25 + (Math.sin(_angle) * 50);

            //            context.moveTo(guideStartingX, guideStartingY);

            //            var distanceX = Math.abs(PUZZLEBOBBLEGAME.FIELD_ENDX - 25 - (_x + 25));
            //            //var distanceX = (_x + 25) - PUZZLEBOBBLEGAME.FIELD_STARTX;

            //            var dist = (distanceX / Math.cos(_angle));

            //            if (_angle < -(Math.PI / 2))
            //                dist *= -1;

            //            var guideEndingX = _x + 25 + (Math.cos(_angle) * dist);
            //            var guideEndingY = _y + 25 + (Math.sin(_angle) * dist);

            //            //guideEndingX -= 25;
            //            //guideEndingY -= 25;

            //            context.lineTo(guideEndingX, guideEndingY);
            //           
            //            //context.lineTo(guideStartingX * (distanceX / Math.cos(-_angle)), guideStartingY * (distanceX / Math.cos(-_angle)));
            //            context.lineTo(guideEndingX * (Math.cos(_angle) * 500), guideEndingY * (Math.sin(_angle) * 500));
            //            context.stroke();

            //            if ((_x + 25 + (Math.cos(_angle - Math.PI / 2) * 500)) < PUZZLEBOBBLEGAME.FIELD_STARTX) {
            //                context.beginPath();
            //                context.moveTo(PUZZLEBOBBLEGAME.FIELD_STARTX, _y + 25 + (Math.sin(_angle - Math.PI / 2) * 500));
            //                context.lineTo(600, 0);
            //                context.stroke();
            //            }


        };

        this.moveLeft = function () {
            _angle -= 0.1;
            _angle = Math.max(-Math.PI + 0.1, _angle);
            console.log(_angle);



        };

        this.moveRight = function () {
            _angle += 0.1;
            _angle = Math.min(-0.1, _angle);
            console.log(_angle);

        };

        this.getRotationAngle = function () {
            return _angle;
        };

    };
   

    ///////////////////// COMMON

    ///Rectangle.js
    COMMON.Rectangle = function (x, y, width, height) {

        this.position = new COMMON.Vector2(x, y);
        this.width = width;
        this.height = height;

    };

    ///Vector2.js
    COMMON.Vector2 = function (x, y) {
        this.x = x;
        this.y = y;
    };


    ///MenuEntry.js

    GAMESTATEMANAGEMENT.MenuEntry = function (text) {

        this.text = text;
        this.position = new COMMON.Vector2(0, 0);
        this.isSelected = false;
        var domElement = null;

        //        this.addEventListener = function (func) {
        //            domElement.addEventListener("click", func, false);
        //        };


        this.loadContent = function () {

            //            domElement = document.createElement("button");
            //            domElement.innerHTML = this.text;
            //            domElement.style.position = "absolute";
            //            domElement.style.top = this.position.y + "px";
            //            domElement.style.left = this.position.x + "px";
            //            domElement.menuScreen = menuSrcneen;
            //            domElement.addEventListener("click", func, false);

            //            document.body.appendChild(domElement);

        };

        this.unloadContent = function () {
            //document.body.removeChild(domElement);
        };

        //this.isSelected = false;

        this.draw = function (menuScreen) {

            menuScreen.screenManager.context.font = "23pt Calibri";
            menuScreen.screenManager.context.fillStyle = this.isSelected ? "rgba(255,255,0," + menuScreen.getTransitionAlpha() + ")" : "rgba(255,255,255," + menuScreen.getTransitionAlpha() + ")";
            menuScreen.screenManager.context.textAlign = "center";
            menuScreen.screenManager.context.fillText(this.text, this.position.x, this.position.y);
        };

        this.getWidth = function () {

        };


    };


    GAMESTATEMANAGEMENT.NumericLeftRightMenuEntry = function (text, min, max) {

        this.text = text;
        this.max = max || 0;
        this.min = min || 0;

        this.position = new COMMON.Vector2(0, 0);
        this.isSelected = false;

        var value = min;

        this.draw = function (menuScreen) {

            menuScreen.screenManager.context.font = "23pt Calibri";
            menuScreen.screenManager.context.fillStyle = this.isSelected ? "rgba(255,255,0," + menuScreen.getTransitionAlpha() + ")" : "rgba(255,255,255," + menuScreen.getTransitionAlpha() + ")";
            menuScreen.screenManager.context.textAlign = "center";
            menuScreen.screenManager.context.fillText(this.text + ":  < " + value + " >", this.position.x, this.position.y);
        };

        this.increase = function () {
            value = Math.min(max, value + 1);
        };

        this.decrease = function () {
            value = Math.max(min, value - 1);
        };

        this.getValue = function () {
            return value;
        };

        this.setValue = function (newValue) {
            if (newValue != null) {

                if (newValue < min)
                    value = min;
                else if (newValue > max)
                    value = max;
                else
                    value = newValue;

            }


        };

        this.getWidth = function () {

        };


    };

    GAMESTATEMANAGEMENT.NumericLeftRightMenuEntry.prototype = new GAMESTATEMANAGEMENT.MenuEntry();
    GAMESTATEMANAGEMENT.NumericLeftRightMenuEntry.constructor = GAMESTATEMANAGEMENT.NumericLeftRightMenuEntry;   


    COMMON.Event = function () {
        //function to call on event fire
        var eventAction = null;
        var eventActionParent = null

        //subscribe a function to the event
        this.subscribe = function (object, func) {
            eventAction = func;
            eventActionParent = object;
        };

        //fire the event
        this.fire = function (sender, eventArgs) {
            if (eventAction != null) {
                eventAction(sender, eventArgs, eventActionParent);
            }
        };
    };

    //////////////////////////////////////////////////////////////////

//    var jsontext = '{ "id": "level1", "Entities": [ {"type": "Cloud1", "x": 1.0, "y": 1.00, "a": 0.0}, {"type": "Cloud3", "x": 14.0, "y": 2.00, "a": 0.0} ] }';
//    var contact = JSON.parse(jsontext);
//    var fullname = contact.id.Entities[0].type;
//    alert(fullname);

    var gameStateManagement = new GAMESTATEMANAGEMENT.ScreenManager();
    //gameStateManagement.addScreen(new GAMESTATEMANAGEMENT.CompanySplashScreen());
    gameStateManagement.addScreen(new GAMESTATEMANAGEMENT.GameplayScreen());

    var startTime = window.mozAnimationStartTime || Date.now();
    algo();

    function algo(timestamp) {

        var drawStart = (timestamp || Date.now()),
            diff = drawStart - startTime;

        //console.log(diff);
        startTime = drawStart;
        gameStateManagement.render(diff);
        requestAnimationFrame(algo);
        
        //requestAnimationFrame(algo);
        //setTimeout(algo, 1000 / 60);
        //gameStateManagement.render();
    };

    
    


</script>
</html>
